#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"name":"csharp"},{"name":"fsharp","languageName":"F#","aliases":["f#","fs"]},{"name":"html","languageName":"HTML"},{"name":"http","languageName":"HTTP"},{"name":"javascript","languageName":"JavaScript","aliases":["js"]},{"name":"mermaid","languageName":"Mermaid"},{"name":"pwsh","languageName":"PowerShell","aliases":["powershell"]},{"name":"value"}]}}

#!markdown

---

## üß† Lesson 3 ‚Äî Types, Declarations & Naming in F# Interactive

### üîç Purpose
This lesson explores F#'s type system, declaration syntax, and naming conventions, drawing from Sections 1.3, 1.4, and 1.6 of *The Haskell Road*. We'll learn how types help us reason about programs and catch errors early.

---

### üìå Learning Objectives
By the end of this lesson, learners should be able to:
- Write explicit type annotations in F# function declarations
- Understand F#'s type inference and how to query types in FSI
- Apply proper naming conventions for functions, types, and operators
- Distinguish between parametric and ad-hoc polymorphism
- Use types as a tool for mathematical reasoning

---

### üß± Concepts to Introduce
- Type annotations and signatures in F#
- F# Interactive type queries and introspection
- Naming conventions: camelCase vs PascalCase
- Infix vs prefix operator usage
- Polymorphic functions and type variables
- Types as sets of values

---

#!markdown

### üìã Lesson Outline

| Cell | Section | Content | Textbook Reference |
|------|---------|---------|-------------------|
| **1** | **Lesson Overview** | Purpose, objectives, and concepts to introduce | Introduction |
| **2** | **Type Annotations** | Explicit type declarations and signatures<br/>FSI type introspection and queries | Section 1.3 |
| **3-4** | **Naming Conventions** | Function and type naming rules<br/>Infix vs prefix operators | Section 1.4 |
| **5-6** | **Types as Sets** | Understanding types as value sets<br/>Function types and composition | Section 1.6 start |
| **7-8** | **Polymorphism** | Parametric polymorphism with type variables<br/>Generic functions and constraints | Section 1.6 core |
| **9-10** | **Type Reasoning** | Equational reasoning with types<br/>Type safety and error prevention | Section 1.6 application |
| **11-12** | **Advanced Examples** | Complex type signatures<br/>Type-driven development examples | Synthesis |

---

### üéØ Learning Path

```
Type Basics ‚Üí Naming Rules ‚Üí Types as Sets ‚Üí Polymorphism ‚Üí Type Reasoning ‚Üí Mastery
```

**Key Type System Concepts:**
- **Type annotations** (explicit declarations)
- **Type inference** (automatic type detection)
- **Polymorphism** (generic programming)
- **Type safety** (compile-time error prevention)

---

#!fsharp

#!about

#!fsharp

#!connect jupyter --kernel-name .net-fsharp --kernel-spec .net-fsharp

#!csharp

#!connect jupyter --kernel-name f_sharp --kernel-spec f_sharp

#!markdown

## 1. Type Declarations & Annotations
*Based on Section 1.3 of The Haskell Road*

Type annotations serve multiple purposes:
- **Document intent** - Make function contracts explicit
- **Catch mismatches early** - Prevent type-related bugs
- **Aid tooling** - Help FSI provide better feedback
- **Guide reasoning** - Types help us think about correctness

### üè∑Ô∏è F# Type Annotation Syntax

F# uses a different syntax than Haskell, but the concepts are identical:

#!fsharp

#!.net-fsharp

// Basic type annotations in F#
let divides (d: int) (n: int) : bool = n % d = 0
let square (x: int) : int = x * x
let isPositive (x: float) : bool = x > 0.0

// Build complete output string in F#
let typeAnnotationsOutput = 
    "F# Type Annotations Examples:\n" +
    "// Basic type annotations in F#\n" +
    "// Syntax: let functionName (parameter: type) : returnType = ...\n" +
    "\n" +
    "let divides (d: int) (n: int) : bool = n % d = 0\n" +
    "let square (x: int) : int = x * x\n" +
    "let isPositive (x: float) : bool = x > 0.0\n" +
    "\n" +
    "Test Results:\n" +
    $"divides 3 12 = {divides 3 12}\n" +
    $"square 7 = {square 7}\n" +
    $"isPositive -2.5 = {isPositive -2.5}"

// Display with single printfn
printfn "%s" typeAnnotationsOutput

#!markdown

### üîç Type Introspection in F# Interactive

Unlike Haskell's `:t` command, F# Interactive shows type signatures when you define functions. We can also explore types interactively:

#!fsharp

#!.net-fsharp

// F# Interactive type introspection examples
let add x y = x + y
let add5 = add 5
let identity x = x
let compose f g x = f (g x)

// Build complete output string for type introspection
let typeIntrospectionOutput = 
    "F# Type Introspection Examples:\n" +
    "// F# Interactive automatically shows type signatures\n" +
    "\n" +
    "let add x y = x + y\n" +
    "// FSI shows: val add : x:int -> y:int -> int\n" +
    "\n" +
    "// Partial application reveals intermediate types\n" +
    "let add5 = add 5\n" +
    "// FSI shows: val add5 : (int -> int)\n" +
    "\n" +
    "// Polymorphic function (type variables)\n" +
    "let identity x = x\n" +
    "// FSI shows: val identity : 'T -> 'T\n" +
    "\n" +
    "// Function composition\n" +
    "let compose f g x = f (g x)\n" +
    "// FSI shows: val compose : f:('b -> 'c) -> g:('a -> 'b) -> x:'a -> 'c\n" +
    "\n" +
    "Test Results:\n" +
    $"add 3 4 = {add 3 4}\n" +
    $"add5 10 = {add5 10}\n" +
    $"identity 42 = {identity 42}\n" +
    $"compose square add5 3 = {compose square add5 3}"

// Display with single printfn
printfn "%s" typeIntrospectionOutput

#!markdown

## 2. Identifiers & Naming Conventions
*Based on Section 1.4 of The Haskell Road*

F# follows specific naming conventions that make code readable and consistent:

### üìù Naming Rules

#### **Functions & Variables**
- **camelCase** - start with lowercase letter
- Examples: `divides`, `isPrime`, `calculateAverage`

#### **Types & Constructors**  
- **PascalCase** - start with uppercase letter
- Examples: `Boolean`, `Integer`, `MyCustomType`

#### **Operators**
- **Symbolic** - use symbols for mathematical operations
- **Infix vs Prefix** - can be used both ways

#!fsharp

#!.net-fsharp

// F# naming conventions examples
let calculateSquare x = x * x
let isEvenNumber n = n % 2 = 0
let findLeastDivisor = divides

// Custom operators (symbolic names)
let (|>) x f = f x           // Forward pipe operator
let (^*) x y = x * x + y * y // Custom operator

// Build complete output string for naming conventions
let namingConventionsOutput = 
    "F# Naming Conventions Examples:\n" +
    "// Good F# naming conventions\n" +
    "\n" +
    "// Functions: camelCase\n" +
    "let calculateSquare x = x * x\n" +
    "let isEvenNumber n = n % 2 = 0\n" +
    "let findLeastDivisor = divides  // alias for our divides function\n" +
    "\n" +
    "// Custom operators (symbolic names)\n" +
    "let (|>) x f = f x           // Forward pipe operator\n" +
    "let (^*) x y = x * x + y * y // Custom operator\n" +
    "\n" +
    "// Using operators infix vs prefix\n" +
    "let result1 = 5 |> calculateSquare    // infix style\n" +
    "let result2 = (|>) 5 calculateSquare  // prefix style\n" +
    "\n" +
    "let result3 = 3 ^* 4                  // infix: 3¬≤ + 4¬≤ = 25\n" +
    "let result4 = (^*) 3 4                // prefix: same result\n" +
    "\n" +
    "Test Results:\n" +
    $"calculateSquare 6 = {calculateSquare 6}\n" +
    $"isEvenNumber 7 = {isEvenNumber 7}\n" +
    $"5 |> calculateSquare (infix) = {5 |> calculateSquare}\n" +
    $"(|>) 5 calculateSquare (prefix) = {(|>) 5 calculateSquare}\n" +
    $"3 ^* 4 = {3 ^* 4}\n" +
    $"(^*) 3 4 = {(^*) 3 4}"

// Display with single printfn
printfn "%s" namingConventionsOutput

#!markdown

## 3. Types as Sets & Function Types
*Based on Section 1.6 of The Haskell Road*

### üéØ Understanding Types as Sets

In mathematics and programming, types represent **sets of values**:

- `bool` = `{true, false}`
- `int` = `{..., -2, -1, 0, 1, 2, ...}` (within machine limits)
- `string` = all possible text strings
- `int list` = all possible lists of integers

### ‚û°Ô∏è Function Types

Function types describe **mappings between sets**:
- `int -> bool` = all functions from integers to booleans
- `int -> int -> bool` = `int -> (int -> bool)` (curried form)

#!fsharp

#!.net-fsharp

// Function types as mappings between sets
let isOdd (n: int) : bool = n % 2 = 1
let isGreater (x: int) (y: int) : bool = x > y
let isGreaterThan5 = isGreater 5

// Higher-order functions
let applyTwice (f: int -> int) (x: int) : int = f (f x)
let increment x = x + 1
let double x = x * 2

// Function composition
let addThenSquare x = square (add 2 x)

// Build complete output string for function types
let functionTypesOutput = 
    "Function Types as Mappings Between Sets:\n" +
    "// Function types describe mappings between sets:\n" +
    "// int -> bool = all functions from integers to booleans\n" +
    "// int -> int -> bool = int -> (int -> bool) (curried form)\n" +
    "\n" +
    "F# Function Definitions:\n" +
    "// int -> bool (maps integers to booleans)\n" +
    "let isOdd (n: int) : bool = n % 2 = 1\n" +
    "\n" +
    "// int -> int -> bool (curried: int -> (int -> bool))\n" +
    "let isGreater (x: int) (y: int) : bool = x > y\n" +
    "\n" +
    "// Partial application creates new function types\n" +
    "let isGreaterThan5 = isGreater 5  // This has type: int -> bool\n" +
    "\n" +
    "// Higher-order functions: functions that take functions as parameters\n" +
    "let applyTwice (f: int -> int) (x: int) : int = f (f x)\n" +
    "\n" +
    "Test Results:\n" +
    $"isOdd 7 = {isOdd 7}\n" +
    $"isGreater 8 3 = {isGreater 8 3}\n" +
    $"isGreaterThan5 10 = {isGreaterThan5 10}\n" +
    $"applyTwice increment 5 = {applyTwice increment 5}\n" +
    $"applyTwice double 3 = {applyTwice double 3}\n" +
    $"addThenSquare 5 = {addThenSquare 5}"

// Display with single printfn
printfn "%s" functionTypesOutput

#!markdown

## 4. Parametric Polymorphism
*Based on Section 1.6 of The Haskell Road*

### üîÑ Generic Programming with Type Variables

**Parametric polymorphism** allows functions to work with **any type**. F# uses **type variables** (like `'T`, `'a`, `'b`) to represent "any type":

### üéØ Benefits:
- **Code reuse** - One function works for many types
- **Type safety** - Still maintains compile-time checking
- **Mathematical elegance** - Captures essential patterns

### üîç Most General Type Principle:
F# infers the **most general type** possible, using type variables where specific types aren't required.

#!fsharp

#!.net-fsharp

// Parametric polymorphism - functions with type variables
let identity x = x
let constant x _ = x  
let swap (x, y) = (y, x)

let head lst = 
    match lst with
    | [] -> failwith "Empty list"
    | h :: _ -> h

let length lst =
    let rec countRec acc = function
        | [] -> acc
        | _ :: tail -> countRec (acc + 1) tail
    countRec 0 lst

// Build complete output string for parametric polymorphism
let polymorphismOutput = 
    "Parametric Polymorphism - Functions with Any Type:\n" +
    "// Functions that work with ANY type using type variables\n" +
    "\n" +
    "// The identity function: works with ANY type\n" +
    "let identity x = x\n" +
    "// Type: 'T -> 'T\n" +
    "\n" +
    "// The constant function: ignores second argument\n" +
    "let constant x _ = x\n" +
    "// Type: 'T1 -> 'T2 -> 'T1\n" +
    "\n" +
    "// Swap function: swaps elements of a tuple\n" +
    "let swap (x, y) = (y, x)\n" +
    "// Type: 'a * 'b -> 'b * 'a\n" +
    "\n" +
    "// List operations (polymorphic over list element type)\n" +
    "let head lst = match lst with | [] -> failwith \"Empty\" | h :: _ -> h\n" +
    "// Type: 'T list -> 'T\n" +
    "\n" +
    "Test Results:\n" +
    $"identity 42 = {identity 42}\n" +
    "identity \"hello\" = " + string (identity "hello") + "\n" +
    $"identity true = {identity true}\n" +
    "constant 5 \"ignored\" = " + string (constant 5 "ignored") + "\n" +
    "constant \"kept\" 999 = " + string (constant "kept" 999) + "\n" +
    "swap (1, \"hello\") = " + string (swap (1, "hello")) + "\n" +
    $"swap (true, 3.14) = {swap (true, 3.14)}\n" +
    $"head [1; 2; 3] = {head [1; 2; 3]}\n" +
    "head [\"a\"; \"b\"] = " + string (head ["a"; "b"]) + "\n" +
    $"length [1; 2; 3; 4] = {length [1; 2; 3; 4]}"

// Display with single printfn
printfn "%s" polymorphismOutput

#!markdown

## 5. Type Constraints & Specialized Polymorphism
*Extended from Section 1.6 of The Haskell Road*

### ‚öñÔ∏è When Polymorphism Has Limits

Some operations require **specific capabilities** from types:
- **Equality** - comparing values for sameness
- **Ordering** - determining which value is greater
- **Arithmetic** - mathematical operations

F# handles this through **type constraints** and **built-in operations**:

#!fsharp

#!.net-fsharp

// Type constraints examples
let areEqual x y = x = y
let maximum x y = if x > y then x else y
let addNumbers x y = x + y
let listEquals lst1 lst2 = lst1 = lst2
let inline addGeneric x y = x + y

// Build complete output string for type constraints
let typeConstraintsOutput = 
    "Type Constraints - When Polymorphism Has Limits:\n" +
    "// Some operations require specific capabilities from types:\n" +
    "// - Equality - comparing values for sameness\n" +
    "// - Ordering - determining which value is greater\n" +
    "// - Arithmetic - mathematical operations\n" +
    "\n" +
    "F# Type Constraint Examples:\n" +
    "// Equality constraint - works with any type that supports comparison\n" +
    "let areEqual x y = x = y\n" +
    "\n" +
    "// Generic comparison function\n" +
    "let maximum x y = if x > y then x else y\n" +
    "// Works with any type supporting comparison (IComparable)\n" +
    "\n" +
    "// Arithmetic constraint - needs numeric types\n" +
    "let addNumbers x y = x + y\n" +
    "\n" +
    "// Advanced: function that works with any numeric type\n" +
    "let inline addGeneric x y = x + y\n" +
    "// The 'inline' keyword enables true generic arithmetic\n" +
    "\n" +
    "Test Results:\n" +
    $"areEqual 5 5 = {areEqual 5 5}\n" +
    "areEqual \"hello\" \"hello\" = " + string (areEqual "hello" "hello") + "\n" +
    $"areEqual [1;2] [1;2] = {areEqual [1;2] [1;2]}\n" +
    $"maximum 10 5 = {maximum 10 5}\n" +
    "maximum \"zebra\" \"apple\" = " + string (maximum "zebra" "apple") + "\n" +
    $"addNumbers 3 7 = {addNumbers 3 7}\n" +
    $"addGeneric 3.5 2.1 = {addGeneric 3.5 2.1}\n" +
    $"listEquals [1;2;3] [1;2;3] = {listEquals [1;2;3] [1;2;3]}\n" +
    "listEquals [\"a\"] [\"b\"] = " + string (listEquals ["a"] ["b"])

// Display with single printfn
printfn "%s" typeConstraintsOutput

#!markdown

## 6. Equational Reasoning & Type Safety
*Based on Section 1.6 of The Haskell Road*

### üßÆ Types Enable Mathematical Reasoning

**Well-typed programs** have powerful properties:
- **Type safety** - certain errors are impossible at runtime
- **Equational laws** - mathematical properties hold uniformly
- **Parametricity** - polymorphic functions behave consistently

### üéØ Examples of Type-Safe Reasoning:

1. **Identity Law**: `identity x = x` for ALL types
2. **Composition Law**: `compose f g x = f (g x)` always holds
3. **No Type Confusion**: Can't accidentally apply `head` to a number

#!fsharp

#!.net-fsharp

// Type safety and equational reasoning examples
let f x = x + 1
let g x = x * 2

let manualComposition x = f (g x)
let automaticComposition = compose f g

let swapTwice pair = swap (swap pair)

// Build complete output string for equational reasoning
let equationalReasoningOutput = 
    "Type Safety and Equational Reasoning:\n" +
    "// Well-typed programs have powerful properties:\n" +
    "// - Type safety - certain errors are impossible at runtime\n" +
    "// - Equational laws - mathematical properties hold uniformly\n" +
    "// - Parametricity - polymorphic functions behave consistently\n" +
    "\n" +
    "Mathematical Laws Demonstration:\n" +
    "\n" +
    "1. Identity Law: identity x = x for ALL types\n" +
    "   identity 42 (int) = " + string (identity 42) + ", equal? " + string (identity 42 = 42) + "\n" +
    "   identity \"hello\" (string) = " + string (identity "hello") + ", equal? " + string (identity "hello" = "hello") + "\n" +
    "   identity [1; 2; 3] (list) = " + string (identity [1; 2; 3]) + ", equal? " + string (identity [1; 2; 3] = [1; 2; 3]) + "\n" +
    "\n" +
    "2. Composition Law: f(g(x)) = compose f g x\n" +
    $"   f(g(5)) = {manualComposition 5}, compose f g 5 = {automaticComposition 5}, equal? {manualComposition 5 = automaticComposition 5}\n" +
    $"   f(g(10)) = {manualComposition 10}, compose f g 10 = {automaticComposition 10}, equal? {manualComposition 10 = automaticComposition 10}\n" +
    "\n" +
    "3. Parametricity: swapTwice equals original for ANY types\n" +
    "   swapTwice (1, \"hello\") = " + string (swapTwice (1, "hello")) + ", equal to original? " + string (swapTwice (1, "hello") = (1, "hello")) + "\n" +
    "   swapTwice (true, 3.14) = " + string (swapTwice (true, 3.14)) + ", equal to original? " + string (swapTwice (true, 3.14) = (true, 3.14)) + "\n" +
    "   swapTwice (\"a\", \"b\") = " + string (swapTwice ("a", "b")) + ", equal to original? " + string (swapTwice ("a", "b") = ("a", "b"))

// Display with single printfn
printfn "%s" equationalReasoningOutput

#!markdown

## 7. Advanced Type Examples & Patterns
*Synthesis and Extension*

### üèóÔ∏è Building Complex Type Signatures

Let's explore more sophisticated examples that combine the concepts we've learned:

### üéØ Patterns We'll Explore:
- **Higher-order functions** with multiple type parameters
- **Recursive type relationships** 
- **Type-driven development** - letting types guide implementation
- **Complex function composition**

#!fsharp

#!.net-fsharp

// Advanced type signatures and patterns
let applyFunctionPair (f: 'a -> 'b) (g: 'c -> 'd) (x: 'a) (y: 'c) : ('b * 'd) =
    (f x, g y)

let rec fold (folder: 'state -> 'element -> 'state) (initial: 'state) (lst: 'element list) : 'state =
    match lst with
    | [] -> initial
    | head :: tail -> fold folder (folder initial head) tail

let map (mapper: 'a -> 'b) (lst: 'a list) : 'b list =
    fold (fun acc elem -> acc @ [mapper elem]) [] lst

let filter (predicate: 'a -> bool) (lst: 'a list) : 'a list =
    fold (fun acc elem -> if predicate elem then acc @ [elem] else acc) [] lst

let curry (f: ('a * 'b) -> 'c) : ('a -> 'b -> 'c) =
    fun x y -> f (x, y)

let uncurry (f: 'a -> 'b -> 'c) : (('a * 'b) -> 'c) =
    fun (x, y) -> f x y

// Test data and setup
let add_uncurried (x, y) = x + y
let add_curried = curry add_uncurried
let multiply_curried x y = x * y
let multiply_uncurried = uncurry multiply_curried
let stringOfInt = string
let sqrt x = System.Math.Sqrt(float x)
let numbers = [1; 2; 3; 4; 5]

// Build complete output string for advanced type examples
let advancedTypesOutput = 
    "Advanced Type Signatures and Patterns:\n" +
    "// Building complex type signatures that combine concepts\n" +
    "\n" +
    "Higher-Order Function Examples:\n" +
    "// Takes two functions and applies them to different arguments\n" +
    "let applyFunctionPair (f: 'a -> 'b) (g: 'c -> 'd) (x: 'a) (y: 'c) : ('b * 'd)\n" +
    "\n" +
    "// Fold function for lists (fundamental higher-order pattern)\n" +
    "let rec fold (folder: 'state -> 'element -> 'state) (initial: 'state) (lst: 'element list) : 'state\n" +
    "\n" +
    "// Map function using fold (type-driven development)\n" +
    "let map (mapper: 'a -> 'b) (lst: 'a list) : 'b list\n" +
    "\n" +
    "// Filter function using fold\n" +
    "let filter (predicate: 'a -> bool) (lst: 'a list) : 'a list\n" +
    "\n" +
    "// Curry and uncurry functions (function transformation)\n" +
    "let curry (f: ('a * 'b) -> 'c) : ('a -> 'b -> 'c)\n" +
    "let uncurry (f: 'a -> 'b -> 'c) : (('a * 'b) -> 'c)\n" +
    "\n" +
    "Test Results:\n" +
    $"applyFunctionPair: (string(42), sqrt(16.0)) = {applyFunctionPair stringOfInt sqrt 42 16.0}\n" +
    $"fold (+) 0 [1;2;3;4;5] = {fold (+) 0 numbers}\n" +
    $"map square [1;2;3;4;5] = {map square numbers}\n" +
    $"filter isOdd [1;2;3;4;5] = {filter (fun x -> x % 2 = 1) numbers}\n" +
    $"curry/uncurry test: add_curried 3 4 = {add_curried 3 4}, multiply_uncurried (3, 4) = {multiply_uncurried (3, 4)}"

// Display with single printfn
printfn "%s" advancedTypesOutput

#!markdown

---

## 8. What We've Learned from *The Haskell Road*

In this lesson, we've explored fundamental concepts from Sections 1.3, 1.4, and 1.6 of *The Haskell Road to Logic, Math and Programming*, adapted to F#:

### üè∑Ô∏è Type System Concepts
1. **Type Annotations** - Explicit type declarations for clarity and safety
2. **Type Inference** - F#'s ability to deduce types automatically
3. **Naming Conventions** - Professional code organization standards
4. **Types as Sets** - Mathematical foundation of type systems

### üîÑ Polymorphism & Generics  
1. **Parametric Polymorphism** - Functions that work with any type
2. **Type Variables** - Generic programming with `'T`, `'a`, `'b`
3. **Type Constraints** - When operations require specific capabilities
4. **Most General Type** - F#'s principle of maximal generality

### üßÆ Mathematical Properties
1. **Equational Reasoning** - Laws that hold due to types
2. **Type Safety** - Compile-time error prevention
3. **Parametricity** - Uniform behavior across type instantiations
4. **Compositionality** - Building complex functions from simple ones

### üîÆ Looking Ahead

The next lessons will build on these type foundations:
- **Algebraic Data Types** (Sum and Product types)
- **Pattern Matching** (Destructuring data safely)
- **Recursive Types** (Lists, Trees, and other structures)
- **Type-Driven Development** (Letting types guide design)

---

### üìñ Textbook Connection

| Section | *The Haskell Road* Content | Our F# Implementation |
|---------|---------------------------|----------------------|
| 1.3 | Type Declarations | F# type annotations and signatures |
| 1.4 | Naming Conventions | camelCase vs PascalCase, operators |
| 1.6 | Types as Sets | Function types, polymorphism, constraints |

---

#!markdown

---

## üîÑ Part II: Category Theory Foundations
*Based on Category Theory for Programmers, Chapters 1-2*

Having explored F#'s type system, we now turn to a deeper understanding of **composition** and **functions as arrows**. Category Theory provides a mathematical framework that illuminates the essence of functional programming.

### üéØ Extended Learning Goals
1. **Functions as Arrows** - Understand how functions correspond to arrows in a category
2. **Composition Laws** - Master associativity and identity properties  
3. **Types as Objects** - See types as the "objects" that arrows connect
4. **Pure vs Impure** - Use types to model effects and maintain composability
5. **Algebraic Thinking** - Apply categorical insights to practical F# programming

---

#!fsharp

#!.net-fsharp

// Final exploration exercises
let myPolymorphicFunction x y = (x, y, x)

let safeDivision (x: float) (y: float) : float option =
    if y = 0.0 then None else Some (x / y)

let twice f x = f (f x)
let thrice f x = f (f (f x))

let testParametricity () =
    let intResult = twice increment 5
    let stringResult = twice (fun s -> s + "!") "hello"
    let listResult = twice (fun lst -> 0 :: lst) [1; 2]
    (intResult, stringResult, listResult)

let mystery : ('a -> 'b) -> ('c -> 'a) -> 'c -> 'b = 
    fun f g x -> f (g x)

// Test parametricity and get results
let (intRes, stringRes, listRes) = testParametricity ()

// Build complete output string for final exploration
let finalExplorationOutput = 
    "üéØ Final Exploration Exercises:\n" +
    "\n" +
    "1. Create your own polymorphic function\n" +
    "let myPolymorphicFunction x y = (x, y, x)  // What's the type?\n" +
    "// Type: 'a -> 'b -> ('a * 'b * 'a)\n" +
    "Test: myPolymorphicFunction 1 \"hello\" = " + string (myPolymorphicFunction 1 "hello") + "\n" +
    "\n" +
    "2. Design a type-safe function that can't go wrong\n" +
    "let safeDivision (x: float) (y: float) : float option =\n" +
    "    if y = 0.0 then None else Some (x / y)\n" +
    $"Test: safeDivision 10.0 2.0 = {safeDivision 10.0 2.0}\n" +
    $"Test: safeDivision 10.0 0.0 = {safeDivision 10.0 0.0}\n" +
    "\n" +
    "3. Create higher-order functions\n" +
    "let twice f x = f (f x)\n" +
    "let thrice f x = f (f (f x))\n" +
    $"Test: twice increment 5 = {twice increment 5}\n" +
    $"Test: thrice increment 5 = {thrice increment 5}\n" +
    "\n" +
    "4. Demonstrate parametricity with different types\n" +
    "// Shows how polymorphic functions work uniformly across types\n" +
    $"twice increment 5 = {intRes}\n" +
    "twice (+ \"!\") \"hello\" = " + string stringRes + "\n" +
    "twice (0::) [1; 2] = " + string listRes + "\n" +
    "\n" +
    "5. Type-driven development: implement based on signature\n" +
    "mystery : ('a -> 'b) -> ('c -> 'a) -> 'c -> 'b\n" +
    "// This is function composition! mystery = compose\n" +
    $"Test: mystery square increment 5 = {mystery square increment 5}\n" +
    "\n" +
    "‚úÖ All exercises demonstrate the power of F#'s type system!"

// Display with single printfn
printfn "%s" finalExplorationOutput

#!markdown

---

## üìö References & Further Reading

### Primary Sources

#### [HR] The Haskell Road to Logic, Math and Programming
- **Authors**: Kees Doets, Jan van Eijck  
- **Publisher**: King's College Publications  
- **Sections Used**: 1.3, 1.4, 1.6
- **Key Concepts**: 
  - Section 1.3: Type Declarations and Annotations
  - Section 1.4: Naming Conventions and Identifiers
  - Section 1.6: Types as Sets, Polymorphism, and Type Safety
- **Adaptation Notes**: Haskell type syntax adapted to F# annotation style

#### [#CTFP] Category Theory for Programmers
- **Author**: Bartosz Milewski
- **Publisher**: Self-published (available as PDF)
- **Sections Used**: Chapters 1-2 (Functions, Composition, Types)
- **Key Concepts**:
  - Chapter 1: Functions as Arrows, Composition Laws, Programming as Category Theory
  - Chapter 2: Types and Functions, Pure vs Impure, Algebraic Data Types
- **Adaptation Notes**: Haskell examples translated to F# with .NET-specific considerations

#### [TAPL] Types and Programming Languages
- **Author**: Benjamin C. Pierce
- **Publisher**: MIT Press
- **Sections Used**: Chapters 1-3 (type basics)
- **Relevance**: Theoretical foundations of type systems

#### [RWH] Real World Haskell
- **Authors**: Bryan O'Sullivan, Don Stewart, John Goerzen
- **Publisher**: O'Reilly Media
- **Sections Used**: Chapters 2-4 (types and functions)
- **Relevance**: Practical type system usage patterns

### F# Technical Resources

#### Microsoft F# Documentation
- **F# Type System Guide**: [docs.microsoft.com/fsharp/language-reference/type-inference](https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/type-inference)
- **F# Generics**: [docs.microsoft.com/fsharp/language-reference/generics](https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/generics)

#### Key F# Type Features Used
- `'T, 'a, 'b` - Type variable syntax for polymorphism
- `inline` - Statically resolved type parameters
- `option<'T>` - Built-in algebraic data type for optional values
- Type annotations: `(parameter: type) : returnType`

### Mathematical Background

#### Type Theory Concepts
1. **Types as Sets**: Correspondence between types and mathematical sets
2. **Function Types**: Set-theoretic interpretation of `->` operator
3. **Parametricity**: Free theorems from polymorphic types
4. **Type Safety**: Progress and preservation properties

#### Proof Techniques Demonstrated
- **Equational Reasoning**: Using types to prove program properties
- **Parametricity**: Universal properties of polymorphic functions  
- **Type-Driven Development**: Letting types guide implementation

### üîó Cross-References

**Previous**: [Lesson 1 - Getting Started with F# Interactive](../module1_lesson1_logic_truth_proof.dib)  
**Next**: [Lesson 4 - Algebraic Data Types & Pattern Matching](../module1_lesson4_algebraic_types.dib)  
**Module Overview**: [Module 1 - Logic, Programming, and Reasoning](../module1.md)  
**Course Home**: [F# Learning Path](../../../README.md)

### üìñ Citation Format

When referencing this lesson:
> Module 1, Lesson 3: Types, Declarations & Naming in F# Interactive. *Learn F# Functional Programming Curriculum*. Based on Doets & van Eijck, *The Haskell Road to Logic, Math and Programming*, Sections 1.3, 1.4, 1.6; and Milewski, *Category Theory for Programmers*, Chapters 1-2.

### üéì Learning Assessment

**Self-Check Questions:**
1. Can you write type annotations for the functions you create?
2. Do you understand the difference between parametric and ad-hoc polymorphism?
3. Can you predict what types F# will infer for your functions?
4. Do you follow proper F# naming conventions?
5. Can you explain how functions relate to arrows in Category Theory?
6. Do you understand the laws of composition and why they matter?
7. Can you distinguish between pure and impure functions using types?
8. Can you create and work with algebraic data types?

**Next Steps:**
- Experiment with creating your own polymorphic functions
- Practice reading complex type signatures
- Explore F#'s built-in generic collections
- Work through the Category Theory challenges
- Think about composition when designing functions
- Practice modeling effects with proper types
- Prepare for algebraic data types in upcoming lessons

#!markdown

---

## 9. Functions as Arrows & Category Theory Foundations
*Based on Chapter 1 of Category Theory for Programmers*

### üèπ The Essence of Composition

From Category Theory, we learn a powerful perspective: **functions are arrows** that connect types, and **composition is the fundamental operation** that lets us build complex programs from simple pieces.

### üéØ Key Insights:
1. **Objects = Types** (`int`, `string`, `bool`, etc.)
2. **Arrows = Functions** (`int -> string`, `string -> bool`, etc.)
3. **Composition** is how we connect arrows end-to-end
4. **Laws of composition** ensure our reasoning is sound

### üìê Why This Matters:
- **Decomposition**: Break complex problems into simple functions
- **Recomposition**: Combine simple functions into complex solutions
- **Interface design**: Small "surface area" (type signature) with large "volume" (implementation)
- **Reasoning**: Mathematical laws guide how we think about programs

#!csharp

#!.net-fsharp

// Functions as Arrows - connecting types
let f (x: int) : string = x.ToString()     // int -> string
let g (s: string) : float = float s        // string -> float  
let h (x: float) : bool = x > 0.0          // float -> bool

// Test the arrow chain
let testValue = 42
let afterF = f testValue      // int -> string
let afterG = g afterF        // string -> float  
let afterH = h afterG        // float -> bool

// Build complete output string for functions as arrows
let functionsAsArrowsOutput = 
    "Functions as Arrows - Connecting Types:\n" +
    "// In Category Theory: Objects = Types, Arrows = Functions\n" +
    "\n" +
    "// Define our arrows (functions)\n" +
    "let f (x: int) : string = x.ToString()     // int -> string\n" +
    "let g (s: string) : float = float s        // string -> float\n" +
    "let h (x: float) : bool = x > 0.0          // float -> bool\n" +
    "\n" +
    "// Visual representation:\n" +
    "// int --f--> string --g--> float --h--> bool\n" +
    "\n" +
    "// Trace a value through the arrow chain:\n" +
    $"Starting value: {testValue} (int)\n" +
    $"After f: {afterF} (string)\n" +
    $"After g: {afterG} (float)\n" +
    $"After h: {afterH} (bool)\n" +
    "\n" +
    "‚úÖ Each arrow transforms one type into another!"

// Display with single printfn
printfn "%s" functionsAsArrowsOutput

#!markdown

## 10. Composition: The Heart of Programming
*Based on Chapter 1.2 of Category Theory for Programmers*

### üîó Definition
**Composition** (`‚àò` in math, `>>` or `<<` in F#) stitches arrows end-to-end:
- If `f : A ‚Üí B` and `g : B ‚Üí C`, then `g ‚àò f : A ‚Üí C`

### ‚öñÔ∏è The Laws of Composition

#### 1. **Associativity**
For functions `f : A ‚Üí B`, `g : B ‚Üí C`, `h : C ‚Üí D`:
```
h ‚àò (g ‚àò f) = (h ‚àò g) ‚àò f
```

#### 2. **Identity**  
There exists an identity function `id : T ‚Üí T` such that:
```
id ‚àò f = f = f ‚àò id
```

These laws ensure that **composition is well-behaved** and our reasoning is mathematically sound.

#!csharp

#!.net-fsharp

// Composition in F# - demonstrating the laws
let id x = x  // Identity function

// Our arrow functions from before
let f (x: int) : string = x.ToString()
let g (s: string) : float = float s  
let h (x: float) : bool = x > 0.0

// Composition operators in F#
let composeForward f g x = x |> f |> g    // f >> g
let composeBackward g f x = x |> f |> g   // g << f

// Manual composition for demonstration
let gAfterF x = g (f x)        // int -> float
let hAfterG x = h (g x)        // string -> bool
let hAfterGAfterF x = h (g (f x))  // int -> bool

// Test associativity: h ‚àò (g ‚àò f) = (h ‚àò g) ‚àò f
let leftAssoc = composeForward (composeForward f g) h
let rightAssoc = composeForward f (composeForward g h)

// Test identity laws: id ‚àò f = f = f ‚àò id
let idAfterF = composeForward f id
let fAfterId = composeForward id f

let testInput = 42

// Build complete output for composition laws
let compositionLawsOutput = 
    "Composition Laws in F#:\n" +
    "// The mathematical laws ensure composition is well-behaved\n" +
    "\n" +
    "1. Identity Function:\n" +
    "let id x = x  // id : 'T -> 'T\n" +
    "\n" +
    "2. Composition Definition:\n" +
    "// If f : A -> B and g : B -> C, then g ‚àò f : A -> C\n" +
    "let f (x: int) : string = x.ToString()  // int -> string\n" +
    "let g (s: string) : float = float s     // string -> float\n" +
    "let h (x: float) : bool = x > 0.0       // float -> bool\n" +
    "\n" +
    "3. Testing Associativity: h ‚àò (g ‚àò f) = (h ‚àò g) ‚àò f\n" +
    $"Left grouping h(g(f({testInput}))): {leftAssoc testInput}\n" +
    $"Right grouping h(g(f({testInput}))): {rightAssoc testInput}\n" +
    $"Equal? {leftAssoc testInput = rightAssoc testInput}\n" +
    "\n" +
    "4. Testing Identity Laws: id ‚àò f = f = f ‚àò id\n" +
    $"f({testInput}) = {f testInput}\n" +
    $"(id ‚àò f)({testInput}) = {idAfterF testInput}\n" +
    $"(f ‚àò id)({testInput}) = {fAfterId testInput}\n" +
    $"All equal? {f testInput = idAfterF testInput && f testInput = fAfterId testInput}\n" +
    "\n" +
    "‚úÖ Composition laws verified - our reasoning is mathematically sound!"

// Display with single printfn
printfn "%s" compositionLawsOutput

#!markdown

## 11. Types and Functions: Building Safe Compositions
*Based on Chapter 2 of Category Theory for Programmers*

### üéØ Why Types Matter for Composition

Types serve as **contracts** that ensure functions can be composed safely:
- **Compile-time safety**: Only functions with matching types can compose
- **Documentation**: Type signatures tell us exactly what each function does
- **Reasoning**: Types guide our thinking about program structure

### üß± Categories of Functions

#### **Pure Functions**
- No side effects, deterministic results
- Correspond directly to mathematical arrows
- Easy to reason about and compose

#### **Impure Functions** 
- Have side effects (IO, mutation, exceptions)
- We model them using special types: `Async<'T>`, `Result<'T,'E>`, `Option<'T>`
- Still composable, but with additional structure

### üìê Types as Sets
Each type represents the **set of all possible values**:
- `bool` = `{true, false}`
- `int` = `{..., -1, 0, 1, 2, ...}` (within machine limits)
- `Option<'T>` = `{None} ‚à™ {Some(x) | x ‚àà 'T}`

#!csharp

#!.net-fsharp

// Pure vs Impure Functions in F#

// PURE FUNCTIONS - no side effects, always composable
let pureAdd (x: int) (y: int) : int = x + y
let pureMultiply (x: int) (y: int) : int = x * y
let pureComposed = pureAdd 10 >> pureMultiply 2  // int -> int

// IMPURE FUNCTIONS - modeled with special types
let safeDiv (x: float) (y: float) : Result<float, string> =
    if y = 0.0 then Error "Division by zero" 
    else Ok (x / y)

let parseNumber (s: string) : Option<int> =
    match System.Int32.TryParse(s) with
    | (true, n) -> Some n
    | (false, _) -> None

// Algebraic Data Types (Sum and Product types)
type Color = Red | Green | Blue  // Sum type: Color = Red + Green + Blue

type Point = { X: float; Y: float }  // Product type: Point = float √ó float

type Result<'T, 'E> = 
    | Ok of 'T      // Success case
    | Error of 'E   // Failure case

// Function to work with our algebraic types
let colorToHex = function
    | Red -> "#FF0000"
    | Green -> "#00FF00" 
    | Blue -> "#0000FF"

let distance (p1: Point) (p2: Point) : float =
    let dx = p1.X - p2.X
    let dy = p1.Y - p2.Y
    sqrt (dx * dx + dy * dy)

// Test our examples
let testPoint1 = { X = 0.0; Y = 0.0 }
let testPoint2 = { X = 3.0; Y = 4.0 }

// Build complete output for types and functions
let typesAndFunctionsOutput = 
    "Types and Functions - Building Safe Compositions:\n" +
    "// Types ensure functions compose safely\n" +
    "\n" +
    "1. Pure Functions (no side effects):\n" +
    "let pureAdd (x: int) (y: int) : int = x + y\n" +
    "let pureMultiply (x: int) (y: int) : int = x * y\n" +
    $"pureComposed 5 = {pureComposed 5}  // (5 + 10) * 2 = 30\n" +
    "\n" +
    "2. Impure Functions (modeled with special types):\n" +
    "let safeDiv (x: float) (y: float) : Result<float, string>\n" +
    $"safeDiv 10.0 2.0 = {safeDiv 10.0 2.0}\n" +
    $"safeDiv 10.0 0.0 = {safeDiv 10.0 0.0}\n" +
    "\n" +
    "let parseNumber (s: string) : Option<int>\n" +
    "parseNumber \"42\" = " + string (parseNumber "42") + "\n" +
    "parseNumber \"hello\" = " + string (parseNumber "hello") + "\n" +
    "\n" +
    "3. Algebraic Data Types:\n" +
    "// Sum type (OR): Color = Red | Green | Blue\n" +
    $"colorToHex Red = {colorToHex Red}\n" +
    $"colorToHex Blue = {colorToHex Blue}\n" +
    "\n" +
    "// Product type (AND): Point = { X: float; Y: float }\n" +
    $"distance {testPoint1} {testPoint2} = {distance testPoint1 testPoint2}\n" +
    "\n" +
    "‚úÖ Types guide composition and prevent entire classes of errors!"

// Display with single printfn
printfn "%s" typesAndFunctionsOutput

#!markdown

## 12. Category Theory Challenges
*Hands-on exercises to reinforce the concepts*

These challenges help you internalize the Category Theory perspective on programming:

### üéØ Challenge 1: Composition Laws
Verify the laws of composition with your own functions.

### üéØ Challenge 2: Type Discovery  
Practice reading type signatures and predicting behavior.

### üéØ Challenge 3: Algebraic Data Types
Create and compose functions with sum and product types.

### üéØ Challenge 4: Pure vs Impure
Refactor impure code using proper type modeling.

#!csharp

#!.net-fsharp

// Category Theory Challenges - Interactive Exercises

// Challenge 1: Verify Composition Laws
let stringToLength (s: string) : int = s.Length
let intToSquare (n: int) : int = n * n  
let squareToString (n: int) : string = $"Square: {n}"

// Test associativity manually
let f = stringToLength
let g = intToSquare  
let h = squareToString

let testString = "hello"

// Left association: h(g(f(x)))
let leftResult = h (g (f testString))

// Right association: (h ‚àò g ‚àò f)(x) 
let composed = f >> g >> h
let rightResult = composed testString

// Challenge 2: Type Discovery - predict then verify
let mysteryFunction x y = (y, x, y)  // What's the type?

// Challenge 3: Create Your Own Algebraic Data Type
type Shape = 
    | Circle of radius: float
    | Rectangle of width: float * height: float
    | Triangle of baseLength: float * height: float

let calculateArea = function
    | Circle radius -> System.Math.PI * radius * radius
    | Rectangle (width, height) -> width * height  
    | Triangle (baseLength, height) -> 0.5 * baseLength * height

// Challenge 4: Model Impure Operations Purely
type FileOperation<'T> = 
    | Read of filename: string
    | Write of filename: string * content: string
    | Success of 'T
    | Failed of error: string

let simulateFileRead (filename: string) : Result<string, string> =
    if filename.EndsWith(".txt") then 
        Ok $"Contents of {filename}"
    else 
        Error "File not found"

// Test our challenges
let circle = Circle 3.0
let rectangle = Rectangle (4.0, 5.0)

// Build complete output for challenges
let challengesOutput = 
    "üéØ Category Theory Challenge Results:\n" +
    "\n" +
    "Challenge 1: Composition Laws Verification\n" +
    "// Functions: string -> int -> int -> string\n" +
    "Input: \"" + testString + "\"\n" +
    "Left association h(g(f(x))): \"" + leftResult + "\"\n" +
    "Right association (h‚àòg‚àòf)(x): \"" + rightResult + "\"\n" +
    $"Laws hold? {leftResult = rightResult}\n" +
    "\n" +
    "Challenge 2: Type Discovery\n" +
    "let mysteryFunction x y = (y, x, y)\n" +
    "// Predicted type: 'a -> 'b -> ('b * 'a * 'b)\n" +
    "mysteryFunction 1 \"hello\" = " + string (mysteryFunction 1 "hello") + "\n" +
    $"mysteryFunction true 42 = {mysteryFunction true 42}\n" +
    "\n" +
    "Challenge 3: Algebraic Data Types\n" +
    "type Shape = Circle | Rectangle | Triangle\n" +
    $"Circle area (radius=3): {calculateArea circle}\n" +
    $"Rectangle area (4√ó5): {calculateArea rectangle}\n" +
    "\n" +
    "Challenge 4: Pure Modeling of Impure Operations\n" +
    "simulateFileRead \"data.txt\" = " + string (simulateFileRead "data.txt") + "\n" +
    "simulateFileRead \"invalid\" = " + string (simulateFileRead "invalid") + "\n" +
    "\n" +
    "‚úÖ All challenges demonstrate Category Theory principles in action!"

// Display with single printfn
printfn "%s" challengesOutput
